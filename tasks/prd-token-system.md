# PRD - 토큰 시스템 1차 도입

## 1. 소개 / 개요
- 핀볼 로그라이크에 ‘토큰’(발라트로의 조커 유사) 시스템을 추가한다. 토큰은 다양한 패시브/트리거 효과를 가지며 덱(7슬롯)에서 관리된다.
- 이번 단계 목표: 토큰 데이터/런타임 구조(토큰 JSON → DTO → Instance → Controller), 덱(7슬롯, 드래그로 순서 변경), 토큰 효과 트리거 처리, 테스트용 토큰 `token.teacher` 구현, DevCommand `addToken`으로 덱에 토큰 추가.

## 2. 목표
1. 토큰 정의/로드/인스턴스화 파이프라인을 핀과 유사한 규격으로 추가한다.
2. 7슬롯 고정 덱 UI/로직을 만들고 드래그로 순서 변경을 지원한다(가득 찼으면 추가 거부).
3. 토큰 효과 처리 체인을 만들고 덱 순서대로 트리거를 평가/실행한다(핀과 동일한 트리거-조건-N이펙트 모델, 전용 `TokenTriggerType` 사용).
4. `token.teacher` 토큰을 구현해 스테이지 종료 시(FlowManager.OnStagePlayFinished 이후, Play→Reward 전환 시점) 플레이어 기본 점수를 영구 +10 한다.
5. `addToken <tokenId> <slotIndex>` DevCommand로 덱에 토큰을 주입해 테스트 가능하게 한다(슬롯 유효성/빈 슬롯 체크, 실패 시 로그).

## 3. 사용자 스토리
- 플레이어로서: 덱에 넣은 토큰이 스테이지마다 효과를 발동해 런을 강화하고, 덱 내 순서가 효과 적용 순서를 결정한다.
- 디자이너/개발자로서: JSON에 토큰을 정의하고 런타임에서 손쉽게 추가/테스트(DevCommand)하며, 다양한 효과를 빠르게 실험한다.
- QA로서: 특정 토큰을 지정 슬롯에 배치하고 스테이지를 플레이해 의도된 트리거 시점에 효과가 발동하는지 확인한다.

## 4. 기능 요구사항
1. **데이터/리포지토리**
   - `StreamingAssets/Data/Tokens.json`(새 파일)에서 토큰 목록을 로드한다. 구조는 핀과 유사하게 `id`, `price`(향후 상점용), `rules`(트리거-조건-효과) 등을 가진다.
   - DTO/리포지토리(`TokenDto`, `TokenRepository`)를 추가하고, `StaticDataManager`가 앱 시작 시 초기화한다.
   - 트리거 enum은 핀과 분리된 `TokenTriggerType`을 사용하되, 조건/이펙트 DTO는 핀과 동일 규격을 재사용 가능하도록 설계한다(중복 정의 최소화).
2. **런타임 인스턴스/컨트롤러**
   - `TokenInstance`는 DTO를 보관하고, 트리거 평가/이펙트 적용을 수행한다.
   - `TokenController`는 UI 슬롯에 붙어 토큰 데이터를 표시/하이라이트/드래그 대응을 담당한다(최소 필요 표시로 시작).
3. **덱 관리(7슬롯)**
   - `TokenManager`를 추가한다: 7슬롯 고정, 빈 슬롯에만 추가 가능, 가득 찼으면 추가 시도 시 거부하고 로그 남김.
   - 덱 내 토큰 순서를 드래그로 바꿀 수 있다(HorizontalLayoutGroup 기반 UI, 슬롯 간 스왑/재정렬). 순서 변경 시 내부 리스트도 갱신한다.
   - 덱 순서가 토큰 효과 처리 순서를 결정한다.
4. **트리거 처리**
   - 토큰 트리거는 기존 핀 트리거 모델과 동일하게 “트리거-조건-다중 이펙트” 구조를 갖는다. `TokenTriggerType`은 최소 `OnStageFinished` 포함.
   - FlowManager의 `OnStagePlayFinished` 흐름(Play→Reward 전환 시점)에서 덱을 순회하며 `OnStageFinished` 트리거를 덱 순서대로 실행한다.
   - 조건/이펙트 처리 시 기존 `PinEffectManager` 로직을 재사용하거나 토큰용 래퍼를 두되, 동일 이펙트 타입을 지원해야 한다.
5. **특수 토큰 구현**
   - `token.teacher`: 트리거 `OnStageFinished`, 조건 Always, 효과: 플레이어 `score`(기본 점수) 영구 +10 (`StatLayer.Permanent`로 적용).
6. **DevCommand**
   - `addToken <tokenId> <slotIndex>`: 리포지토리에서 토큰을 찾고, 지정 슬롯이 비어있고 범위 내이면 덱에 추가. 실패 시 이유를 로그.
   - 덱 UI에 즉시 반영되며, 덱 순서/효과 처리 규칙을 따른다.

## 5. 비목표 / 범위 외
- 상점에서 토큰을 판매/구매하는 기능.
- 덱 슬롯 제거/비우기 UI와 같은 관리 기능.
- 토큰 영속 저장/로드(런 간 유지).
- 고급 UI 연출(애니메이션, 툴팁) 및 밸런스 조정.

## 6. 디자인 고려사항
- 덱 UI: 화면 상단 HorizontalLayoutGroup에 7 슬롯 고정. 슬롯은 기본 상태/비어있음/드래그 중 상태를 구분할 수 있도록 최소한의 비주얼 상태 필요.
- 드래그: 슬롯 간 스왑 또는 재정렬이 직관적으로 보이도록 위치 보정(레이아웃 업데이트) 필요. 마우스/터치 모두 대응(Input System 기반).

## 7. 기술 고려사항
- 데이터 경로/로더: `StaticDataManager`에서 Tokens.json을 로드하도록 확장. SaCache 사용 규칙 준수.
- 트리거/이펙트: `TokenTriggerType`을 분리 정의. 조건/이펙트 DTO는 핀과 공유하거나, 공통 모듈로 뽑아 중복을 줄인다. 처리 순서는 덱 배열 순.
- 통합 시점: FlowManager의 `OnStagePlayFinished`에서 토큰 트리거를 실행해도 기존 핀 처리/스코어 계산 흐름과 충돌이 없어야 함.
- UI 드래그: PinDragManager와 충돌하지 않도록 별도 레이어/UI 전용 처리. 드래그 시 슬롯 인덱스 계산 로직을 명확히 분리.
- 테스트 편의: DevCommand는 에디터/개발 빌드에서만 노출(기존 DevCommandManager 규칙 준수).
- 메타데이터: 토큰에도 가격/희귀도 등 필드를 포함해 향후 상점/밸런스 확장을 대비한다.

## 8. 성공 지표 / 완료 기준
- Tokens.json을 로드해 덱에 토큰을 추가할 수 있고, `addToken token.teacher 0` 실행 시 슬롯 0에 추가된다.
- 스테이지를 마치면 `token.teacher` 효과로 플레이어 기본 점수가 매 스테이지마다 +10(누적) 반영된다(Score UI에 반영).
- 덱에 7개가 찬 상태에서 추가 시도하면 추가되지 않고 로그로 거부 이유가 출력된다.
- 드래그로 덱 내 순서를 바꾸면 이후 트리거 처리 순서도 변경된다(테스트로 확인 가능).

## 9. 결정 및 추가 검토
- 덱 상태는 런타임 세션 한정(영속 저장/로드는 범위 밖).
- 토큰에도 가격/희귀도 등 메타데이터를 포함한다(상점 연계 대비).
- 핀/토큰 효과 처리 구조: 트리거·컨디션·이펙트 모두 별도 파이프라인으로 분리한다. 공통분모가 적어질 것을 감안해 중복 비용을 허용하고, 각 시스템 특화 로직/트리거를 자유롭게 확장한다.
