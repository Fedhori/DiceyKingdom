# 일반 규칙

이 문서는 모든 Unity 프로젝트에서 공통으로 적용되는 환경/규칙/원칙을 정리합니다.

## 문서 범위/분리 기준

- 범용 규칙(모든 Unity 프로젝트 공통)은 이 문서에 기록합니다.
- 프로젝트 특화 규칙/구조는 `Docs/GAME_STRUCTURE.md`(게임 구조) 또는 `Docs/PROJECT_MAP.md`(레포 지도)에 기록합니다.

## Unity 버전

- Unity 6.2 (6000.2.6f2)

## 코드 컨벤션

- C# 4-스페이스 들여쓰기
- Allman braces
- Unity C# 관례 준수
- 코드에서 데이터 모델/변수 네이밍은 camelCase를 사용합니다.
- 코드 식별자(타입/메서드/enum 값)에는 의미가 불명확한 축약 기호(`P1`, `P2` 등)를 사용하지 않습니다.
  - 단계/상태는 의미 기반 이름으로 명명합니다. (예: `TurnStart`, `BoardUpdate`, `Assignment`)

## 데이터 네이밍 규칙

- JSON 키는 camelCase를 사용합니다.
- 코드(C#)에서 JSON 데이터를 매핑한 필드/프로퍼티도 camelCase를 사용합니다.
- JSON 내부의 효과 타입/파라미터 키 문자열도 camelCase로 통일합니다.

## 공용 값 관리 파일(확정)

- 색상 상수는 `Assets/Scripts/Data/Colors.cs`에서 중앙 관리합니다.
  - 예: `AtkBase`, `AtkBonus`, `AtkFinal`
- 인게임 수치 상수는 `Assets/Scripts/Data/GameConfig.cs`에서 중앙 관리합니다.
  - 예: `TooltipShowDelaySeconds = 0.2f`
- 위 두 범주에 해당하는 값을 다른 스크립트에 하드코딩하지 않습니다.

## 구현/협업 규칙

1. 사용자가 “코드 작업”을 지시하기 전에는 구현을 시작하지 않습니다.
2. 코드 변경 시 기존 시스템과 호환되도록 유지합니다.
3. MCP를 통해 씬/프리팹/Inspector 수정을 진행하기 전에, 반드시 어떤 작업을 진행할지 사용자에게 강조하여 안내합니다.
4. `.meta` 파일은 Unity가 관리하므로 직접 생성하거나 수정하지 않습니다.
5. 질문이나 요구에 대해 의문점/개선점이 있으면 반드시 질문·개선사항을 제시합니다. 답변 이후에도 남아 있으면 해결될 때까지 반복적으로 질문·개선사항을 제시합니다.

## 이벤트/상태 관리 원칙(확정)

- 이벤트는 UI 갱신 용도로만 사용합니다. 로직 진행/의사결정(턴 전환, 전투 처리, 규칙 판정)을 이벤트 체인으로 연결하지 않습니다.
- 게임 로직은 매니저 간 직접 메서드 호출로 처리합니다. (`xxxManager.Instance` 호출 허용)
- 상태값/수치값은 Getter/Setter를 적극 사용해 관리합니다.
- UI 갱신이 필요한 수치/상태는 Setter에서 해당 이벤트를 즉시 발행합니다.
- 범용 이벤트(`StateChanged` 등) 대신, 값 단위의 명시적 이벤트를 사용합니다.
  - 예: `OnStabilityChanged`, `OnGoldChanged`, `OnPhaseChanged`

## 작업 추적 규칙 (TODO.md)

- 작업 추적은 루트의 `TODO.md`를 단일 기준으로 사용합니다.
- 어떤 작업이든 시작 전에 `TODO.md`의 `Planned`에 등록하고, 착수 시 `In Progress`로 이동합니다.
- 완료 시 `Done`으로 이동하며 완료일과 핵심 결과를 남깁니다.
- 보류/중단 작업은 `Blocked`에 사유와 함께 기록합니다.
- 작업 진행 중 상태가 바뀌면 즉시 `TODO.md`를 업데이트해 추적 가능성을 유지합니다.

## 하드코딩 금지 원칙(확정)

- 하드코딩은 거의 대부분의 상황에서 금지합니다.
- 불가피하게 하드코딩이 필요한 경우, 아래를 먼저 사용자에게 제시하고 허가를 받은 뒤에만 적용합니다.
  - 사용처(정확한 파일/로직 위치)
  - 하드코딩이 필요한 이유(대체 불가 사유)
  - 대체안 및 추후 제거 계획(리팩토링 시점)
- 데이터/설정으로 표현 가능한 규칙(효과, 수치, 분기)은 코드 분기 대신 데이터 기반으로 구현합니다.

## Inspector 우선 설정 원칙(확정)

- 에디터(Inspector/Scene)에서 설정 가능한 상태값(레이아웃, 앵커, 패딩, 정렬, 크기, 색상 등)은 코드에서 강제 설정하지 않습니다.
- 동일 값이 코드와 에디터에 동시에 존재하면 에디터 설정을 단일 진실원(Source of Truth)으로 사용합니다.
- 코드에서는 참조 확인/누락 경고까지만 수행하고, 값 자체는 변경하지 않습니다.
- 에디터 설정이 필요하면 씬/프리팹 직렬화 데이터에 반영합니다.

## 공통 패턴

- 매니저/컨트롤러는 `public static Instance` 싱글톤 패턴을 사용하며, 중복 생성 시 `Awake`에서 파괴 처리합니다.
- 부팅 흐름은 프로젝트별로 정의하되, `SaCache` 초기화가 필요한 경우 `Bootstrap`에서 수행합니다.
- 데이터 초기화는 `StaticDataManager` 기반의 JSON 로딩 흐름을 사용하며, 실제 데이터 구조는 프로젝트별로 정의합니다.

## 텍스트/로컬라이징

- 모든 질의응답과 설명은 한국어로 작성합니다.
- 모든 텍스트 관련 작업은 반드시 로컬라이징을 고려하며, 코드에 하드코딩된 표현은 사용하지 않습니다.
- 텍스트 스타일을 사용하는 것은 공통 규칙이며, 스타일 이름은 프로젝트별 문서에서 관리합니다.

## 문서 최신화 방법론

- 변경 후 1차 판단: 코드/데이터/씬 변경이 있을 때마다 문서 반영 필요 여부를 먼저 판단하고 사용자에게 고지합니다.
- 문서 분류 기준:
  - 범용 규칙/패턴/컨벤션 변경 → `Docs/GENERAL_RULES.md`
  - 게임 구조/시스템/플로우 변경 → `Docs/GAME_STRUCTURE.md`
  - 파일 위치/역할/진입점 변경 → `Docs/PROJECT_MAP.md`
- 작업 단위 루틴: 변경 목록 확인 → 문서 반영 여부 판단 → 필요한 문서 즉시 갱신(불필요 판단도 1줄 기록).
- 완료 조건: 모든 변경 작업은 “문서 업데이트 여부 확인”을 완료 조건에 포함합니다.
- 정기 점검: 스프린트/월말에 `Docs/PROJECT_MAP.md` 기준으로 코드와 1회 정합성 점검을 수행합니다.
- 의사결정 로그: 사용자 지시가 있을 때만 `Docs/GAME_IDEA.md` 또는 사용자가 지정한 문서에 기록합니다.

## 개발 원칙(실수 방지)

- Input System을 사용합니다. (OnMouseDown / 레거시 마우스 입력 기반 구현 금지)
- 새 패키지/의존성 추가가 필요하면 먼저 사용자에게 요청합니다.
- 변경은 작게 쪼개고, 검증 가능한 단위로 진행합니다.
- 랜덤은 UnityEngine.Random이 아닌 System.Random을 사용합니다.
